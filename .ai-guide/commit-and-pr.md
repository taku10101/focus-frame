# コミットとプルリクエストのガイドライン

このドキュメントは、HomeLogプロジェクトにおけるコミットとプルリクエスト作成のガイドラインを提供します。

## 重要な原則

### 日本語でのコミット・PR作成

**このプロジェクトでは、コミットメッセージとPRは日本語で記述してください。**

- コミットメッセージ本文は日本語で記述
- PRのタイトルと説明は日本語で記述
- コードコメントも日本語を推奨
- 技術用語は英語のまま使用可（例：「refactor」「Clean Architecture」等）

理由：
- チーム全員が日本語ネイティブであり、意図が正確に伝わる
- レビューや議論が円滑に進む
- 将来のメンテナンスで文脈を理解しやすい

### Phaseごとのコミット原則

**開発の各フェーズごとに適切にコミットを分割してください。**

大きな機能開発は以下のようなフェーズに分けてコミットします：

1. **設計・準備フェーズ**
   - 型定義の追加
   - インターフェースの定義
   - スキーマ変更（マイグレーション）
   - 設定ファイルの追加

2. **実装フェーズ**
   - コア機能の実装
   - ビジネスロジックの追加
   - UI コンポーネントの作成

3. **統合フェーズ**
   - 既存コードとの統合
   - エンドポイントの追加
   - ルーティングの設定

4. **テスト・検証フェーズ**
   - テストコードの追加
   - バグ修正
   - エッジケースの対応

5. **ドキュメント・最終調整フェーズ**
   - ドキュメント更新
   - コメント追加
   - リファクタリング

**Phase分割の例：**

```bash
# Phase 1: 型定義
git commit -m "feat(backend): 商品スキャン機能の型定義を追加"

# Phase 2: コア実装
git commit -m "feat(backend): Gemini APIを使用した商品スキャンロジックを実装"

# Phase 3: 統合
git commit -m "feat(backend): 商品スキャンエンドポイントをAPIに追加"

# Phase 4: テスト
git commit -m "test(backend): 商品スキャン機能のテストを追加"

# Phase 5: ドキュメント
git commit -m "docs(backend): 商品スキャンAPIのドキュメントを更新"
```

**Phase分割のメリット：**
- レビューが容易になる（1つのコミットが1つの責務に集中）
- 問題発生時のロールバックが安全
- 開発の進捗が可視化される
- git bisectでのデバッグが効率的になる

## コミットメッセージ形式

Conventional Commits仕様に従います：

```
<type>(<scope>): <subject>

<body>

<footer>
```

### Type（タイプ）

以下のいずれかを使用してください：

- **feat**: 新機能の追加
- **fix**: バグ修正
- **docs**: ドキュメントのみの変更
- **style**: コードの動作に影響しない変更（空白、フォーマット等）
- **refactor**: バグ修正や機能追加を含まないコード変更
- **perf**: パフォーマンス改善
- **test**: テストの追加や修正
- **build**: ビルドシステムや外部依存関係の変更
- **ci**: CI設定ファイルやスクリプトの変更
- **chore**: srcやtestファイル以外の変更
- **revert**: 以前のコミットの取り消し

### Scope（スコープ）

モノレポのどの部分に影響するかを示します：

- **backend**: homelog_backendへの変更
- **mobile**: homelog_RNへの変更
- **root**: ルートレベルのファイルまたは両プロジェクトへの変更
- **deps**: 依存関係の更新
- **database**: データベーススキーマやマイグレーションの変更

**例：**
- `feat(backend): 商品スキャンエンドポイントを追加`
- `fix(mobile): 画像プレビューの回転を修正`
- `docs(root): CLAUDE.mdのセットアップ手順を更新`
- `refactor(backend): アセットリポジトリのロジックを簡素化`

### Subject（件名）

- **日本語で記述**してください
- 命令形・現在形を使用：「追加する」ではなく「追加」
- 最初の文字は小文字
- 文末にピリオド不要
- 最大72文字

### Body（本文）

- **日本語で記述**してください
- 命令形・現在形を使用
- 「どのように」ではなく「何を」「なぜ」を説明
- 件名から1行空けて記述
- 72文字で改行

### Footer（フッター）

- 関連Issueの参照: `Fixes #123` または `Closes #456`
- 破壊的変更: `BREAKING CHANGE: 説明`

### コミットメッセージの例

#### シンプルなコミット
```
feat(backend): 保証期限切れ通知機能を追加

保証期限切れの自動通知システムを実装。
SNSを使用してメール配信を行う。

Closes #45
```

#### 破壊的変更を含むコミット
```
refactor(backend): アセットAPIのレスポンス形式を変更

フラット構造からネスト構造に変更し、
他のエンドポイントとの一貫性を向上。

BREAKING CHANGE: アセットAPIのレスポンス形式が変更されました。
クライアント側でレスポンス解析ロジックの更新が必要です。

Relates to #78
```

#### 依存関係更新
```
chore(deps): Prismaをv5.9.0に更新

セキュリティパッチのため、バックエンドプロジェクトの
Prismaを最新バージョンに更新。
```

#### Phase分割の実例
```
# Phase 1: スキーマ設計
feat(database): 通知設定テーブルを追加

ユーザーごとの通知設定を保存するためのテーブルを追加。
warranty_notificationとdurability_notificationの設定を管理。

# Phase 2: Domainレイヤー実装
feat(backend): 通知設定のドメインモデルを実装

NotificationSettingsエンティティとリポジトリインターフェースを追加。
Clean Architectureの原則に従い、ビジネスロジックを分離。

# Phase 3: Infrastructureレイヤー実装
feat(backend): Prismaを使用した通知設定リポジトリを実装

NotificationSettingsRepositoryの具体実装を追加。
Prismaクライアントを使用してデータベース操作を実装。

# Phase 4: Applicationレイヤー実装
feat(backend): 通知設定のユースケースを実装

通知設定の取得・更新のユースケースを実装。
バリデーションとエラーハンドリングを含む。

# Phase 5: Presentationレイヤー実装
feat(backend): 通知設定APIエンドポイントを追加

GET/PUT /api/notification-settingsエンドポイントを実装。
Auth0認証とバリデーションを含む。

# Phase 6: テスト追加
test(backend): 通知設定機能のテストを追加

ユースケース、リポジトリ、エンドポイントの
ユニットテストと統合テストを追加。
```

## プルリクエスト（PR）ガイドライン

### PRタイトル

コミットメッセージと同じ形式に従います：
```
<type>(<scope>): <subject>
```

**日本語で記述してください。**

例：
- `feat(mobile): アセット詳細画面を追加`
- `fix(backend): アセット更新時のnull処理を修正`

### PRテンプレート

すべてのプルリクエストで以下のテンプレートを使用してください：

```markdown
## 概要
このPRの目的を1-3文で簡潔に説明

## 変更内容
- 主要な変更点をリスト化
- 箇条書きを使用
- 具体的に記述

## Phase分割
このPRは以下のPhaseに分けてコミットしています：
- [ ] Phase 1: 型定義・スキーマ変更
- [ ] Phase 2: コア実装
- [ ] Phase 3: 統合
- [ ] Phase 4: テスト
- [ ] Phase 5: ドキュメント

各Phaseの詳細：
1. Phase 1: 実装内容の説明
2. Phase 2: 実装内容の説明
...

## 変更タイプ
- [ ] バグ修正（既存機能を壊さない修正）
- [ ] 新機能（既存機能を壊さない追加）
- [ ] 破壊的変更（既存機能の動作に影響する修正や機能）
- [ ] ドキュメント更新
- [ ] リファクタリング（機能変更なし）
- [ ] パフォーマンス改善
- [ ] テスト更新

## 影響範囲
- [ ] バックエンドAPI
- [ ] モバイルアプリ
- [ ] データベーススキーマ
- [ ] ドキュメント
- [ ] CI/CD
- [ ] インフラストラクチャ

## テスト
実施したテストの説明：
- [ ] ユニットテスト追加・更新
- [ ] 統合テスト追加・更新
- [ ] 手動テスト実施
- [ ] iOSでテスト済み
- [ ] Androidでテスト済み
- [ ] Webでテスト済み

テストシナリオ：
1. シナリオ1: 手順と期待結果
2. シナリオ2: 手順と期待結果

## スクリーンショット（該当する場合）
UI変更の場合はスクリーンショットや動画を追加

## データベース変更
- [ ] このPRにはデータベースマイグレーションが含まれる
- [ ] マイグレーションをローカルでテスト済み
- [ ] マイグレーションは可逆的

マイグレーション詳細：
- マイグレーションファイル: `prisma/migrations/YYYYMMDDHHMMSS_description/migration.sql`
- 変更内容: スキーマ変更の説明

## 破壊的変更
- [ ] このPRには破壊的変更が含まれる

含まれる場合、以下を記述：
- 何が壊れるか
- 既存ユーザー/データの移行パス
- 依存システムで必要な更新

## Clean Architecture チェック（バックエンドのみ）
- [ ] 依存関係の方向が正しい（外側→内側のみ）
- [ ] Domain層にHTTP用語が含まれていない
- [ ] DTOの配置が適切（domain/dto、application/dto、presentation/dto）
- [ ] OmitよりもPickを優先して使用
- [ ] 関数宣言を使用（アロー関数は非推奨）

## チェックリスト
- [ ] コードがプロジェクトのスタイルガイドラインに従っている
- [ ] セルフレビュー完了
- [ ] 複雑なロジックにコメント追加
- [ ] ドキュメント更新済み
- [ ] 新しい警告が発生していない
- [ ] ローカルでテストが通過
- [ ] 依存する変更がマージ・公開済み

## 関連Issue
Closes #(issue番号)
Relates to #(issue番号)

## 補足事項
追加のコンテキスト、懸念事項、フォローアップ項目など
```

### PRのベストプラクティス

1. **サイズ**: PRは小さく焦点を絞る
   - 変更行数は400行未満を目指す
   - 大きな機能は複数のPRに分割
   - 各PRは単一の目的を持つべき
   - Phase単位でPRを分割することも検討

2. **Draft PR**: 作業中はDraft PRを活用
   - レビュー準備が整うまでDraftとしてマーク
   - アプローチに対する早期フィードバックに有用

3. **Issue連携**: 常に関連Issueをリンク
   - このPRで解決するIssueには`Closes #123`を使用
   - 関連するIssueには`Relates to #456`を使用

4. **テスト**: テスト結果を含める
   - 重要な変更のテスト出力を表示
   - UI変更のスクリーンショットを含める
   - 手動テスト手順を文書化

5. **レビュー**:
   - 関連チームメンバーにレビューを依頼
   - すべてのレビューコメントに対応
   - 変更後は再度レビューを依頼

6. **マージ戦略**:
   - **Squash and merge**: フィーチャーブランチのデフォルト
   - **Rebase and merge**: クリーンな線形履歴のため
   - **Merge commit**: 重要なフィーチャーブランチで履歴を保持

## モノレポ固有のガイドライン

### バックエンド変更（homelog_backend）

- コミット前に必ず`pnpm run typecheck`を実行
- スキーマ変更時はデータベースマイグレーションを含める
- ローカルのPostgreSQLコンテナでテスト
- エンドポイント変更時はAPIドキュメントを更新

**コミット例：**
```
feat(backend): 商品検索エンドポイントを追加
fix(backend): 保証年数の小数点精度を修正
refactor(backend): OCRロジックを別サービスに抽出
```

### モバイル変更（homelog_RN）

- コミット前に必ず`pnpm run typecheck`を実行
- 可能であればiOSとAndroid両方でテスト
- UI変更時はスクリーンショットを含める
- ルート変更時はナビゲーションを更新

**コミット例：**
```
feat(mobile): アセット詳細画面を追加
fix(mobile): プレビューでの画像向きを修正
style(mobile): ダークモードのテーマカラーを更新
```

### 複数プロジェクトにまたがる変更

- 両プロジェクトに影響する場合は`root`スコープを使用
- 可能な限り別々のコミットに分割
- 変更後は両プロジェクトをテスト

**コミット例：**
```
chore(root): TypeScriptを5.3.3に更新
docs(root): セットアップ手順を改善
```

## よくある間違いと回避方法

1. **曖昧なコミットメッセージ**
   - ❌ "バグ修正"
   - ✅ "fix(backend): アセット更新時のnull処理を修正"

2. **スコープの欠落**
   - ❌ "機能追加"
   - ✅ "feat(mobile): 設定画面を追加"

3. **1つのコミットに無関係な変更を含める**
   - Phase分割の原則に従い、適切に分割する

4. **テスト前のコミット**
   - 必ずテストを実行してからコミット

5. **ドキュメントの更新忘れ**
   - API変更時は必ずドキュメントも更新

6. **複数の関心事を混在させた大きなPR**
   - Phase単位やスコープ単位で分割

## Git ワークフロー

1. `main`からフィーチャーブランチを作成：
   ```bash
   git checkout -b feat/backend/product-scan
   ```

2. このガイドラインに従ってコミット作成（Phase分割を意識）

3. プッシュしてPRを作成：
   ```bash
   git push -u origin feat/backend/product-scan
   ```

4. レビューフィードバックに対応

5. 必要に応じてマージ前にコミットをSquash

## ブランチ命名規則

以下のパターンに従います：
```
<type>/<scope>/<description>
```

**説明部分は日本語でも英語でも可**（英語推奨、スペースの代わりにハイフン使用）

**例：**
- `feat/backend/warranty-notification`
- `fix/mobile/image-rotation`
- `docs/root/update-readme`
- `refactor/backend/clean-architecture`

## 緊急修正

本番環境の重大な問題の場合：

1. `main`からhotfixブランチを作成：
   ```bash
   git checkout -b hotfix/critical-auth-bug
   ```

2. `fix`タイプを使用し、明確な説明を記述：
   ```
   fix(backend): 認証ミドルウェアのnullポインタを防止

   500エラーを引き起こす本番問題の緊急修正。
   userオブジェクトアクセス前にnullチェックを追加。

   Fixes #234
   ```

3. レビューとマージを迅速に実施

4. 必要に応じて他のブランチにCherry-pick

## Phase分割の詳細ガイド

### Phase分割が推奨されるケース

- 新機能の追加（複数のレイヤーにまたがる場合）
- 大規模なリファクタリング
- アーキテクチャ変更
- 複数のコンポーネントに影響する変更

### Phase分割が不要なケース

- 1ファイルのみの小さなバグ修正
- ドキュメントのみの更新
- 設定ファイルの軽微な変更
- 単純なスタイル修正

### Clean Architecture における Phase 分割の例

バックエンドでClean Architectureに従う場合、以下のPhase順序を推奨：

```
Phase 1: Domain層（ビジネスロジック）
  - エンティティ定義
  - リポジトリインターフェース
  - ドメインDTOの定義

Phase 2: Infrastructure層（外部依存実装）
  - リポジトリ実装（Prisma）
  - 外部API連携
  - データベースマイグレーション

Phase 3: Application層（ユースケース）
  - ユースケース実装
  - アプリケーションDTOの定義
  - ビジネスルールの実装

Phase 4: Presentation層（API）
  - コントローラー実装
  - ルーティング設定
  - バリデーションスキーマ（Zod）

Phase 5: テストとドキュメント
  - ユニットテスト
  - 統合テスト
  - APIドキュメント更新
```

### モバイルアプリにおける Phase 分割の例

```
Phase 1: 型定義とスキーマ
  - TypeScript型定義
  - Zodバリデーションスキーマ
  - Contextの型定義

Phase 2: UI コンポーネント
  - 基本コンポーネントの実装
  - スタイル定義
  - レイアウト構築

Phase 3: 状態管理とロジック
  - カスタムフック実装
  - Context実装
  - ビジネスロジック

Phase 4: 画面統合
  - 画面コンポーネントの実装
  - ルーティング設定
  - ナビゲーション統合

Phase 5: テストと最適化
  - コンポーネントテスト
  - パフォーマンス最適化
  - ドキュメント更新
```

## 質問がある場合

コミットやPRの構造について不明な点がある場合：

1. 最近のコミット/PRを参照
2. このガイドを確認
3. チームチャットで質問
4. 推測するよりも質問する方が良い

---

**このガイドラインを守ることで、プロジェクトの品質と保守性が向上します。**
